# MyStudyPlanCpp

>1 ) C++ Fundamentals
+ Introduction
+ Variables and Constants
+ Data Types and Input
+ Operators
+ Conditional Statements
+ Loops
+ Functions
- a) Crea un programa que pida al usuario un número entero y lo imprima en pantalla.
- b) Crea un programa que pida al usuario dos números enteros y calcule su suma, resta, multiplicación y división, imprimiendo los resultados en pantalla.
- c) Calculadora de estadísticas básicas: El objetivo es crear una calculadora que permita calcular la media, la mediana, la moda y la desviación estándar de un conjunto de números ingresados por el usuario.
- d) Juego de adivinanza de números: El objetivo es crear un juego en el que el programa genera un número aleatorio entre 1 y 100, y el usuario debe adivinarlo en el menor número de intentos posibles. El programa debe proporcionar retroalimentación al usuario después de cada intento, diciéndole si el número ingresado es demasiado alto o demasiado bajo.
- - -
>2 ) Arrays and Memory Allocation
+ Arrays
+ Pointers
+ Dynamic Memory Allocation
+ Smart Pointers
- a) Crea un programa que pida al usuario el tamaño de un arreglo y los valores de sus elementos, y luego calcule y muestre en pantalla la suma de todos los elementos.
- b) Crea un programa que genere un arreglo de números aleatorios y lo ordene de menor a mayor usando el algoritmo de selección.
- c) Sistema de gestión de empleados: El objetivo es crear un sistema de gestión de empleados en el que se pueda agregar, eliminar, buscar y mostrar información sobre los empleados de una empresa. Puedes utilizar un array de punteros a estructuras de empleado para almacenar los datos de los empleados.
- d) Juego de memoria: El objetivo es crear un juego de memoria en el que el usuario debe recordar la ubicación de las cartas que se muestran brevemente en la pantalla y luego emparejarlas. Puedes utilizar arrays dinámicos para almacenar las cartas y sus ubicaciones en la pantalla.
- - -
>3.0 ) Recursion
- a) Crea una función recursiva que calcule el factorial de un número entero positivo.
- b) Crea una función recursiva que calcule el término n-ésimo de la secuencia de Fibonacci.
- c) Torre de Hanoi mediante recursión: El objetivo es crear una función que resuelva el problema de la Torre de Hanoi mediante la recursión. Puedes utilizar una función que llame a sí misma para mover los discos de una torre a otra, siguiendo las reglas del juego.
- - -
>3.1 ) Tail Recursion
- a) Replica el ejemplo de 3.0a con TailRecursion
- b) Replica el ejemplo de 3.0b con TailRecursion
- c) Replica el ejemplo de 3.0c con TailRecursion
- - -
>4.0) Structures
- a) Crea una estructura llamada "Persona" que contenga los campos "nombre" y "edad", y luego crea un programa que pida al usuario los datos de dos personas y los muestre en pantalla.
- b) Crea una estructura llamada "Rectángulo" que contenga los campos "ancho" y "alto", y luego crea un programa que pida al usuario las dimensiones de un rectángulo y calcule su área y perímetro.
- - -
>4.1) Data Structure: Array
- a) Crea un programa que implemente una matriz (array) bidimensional y que permita sumar, restar y multiplicar matrices. El programa debe también imprimir el resultado en la consola.
- b) Extiende el programa anterior para que permita ordenar una matriz utilizando diferentes algoritmos de ordenamiento como bubble sort, quicksort o mergesort.
- - -
>4.2) Data Structure: LinkedList
- a) Crea un programa que implemente una lista enlazada simple y que permita insertar, eliminar y buscar elementos en ella. También puedes agregar la capacidad de imprimir la lista en la consola.
- b) Extiende el programa anterior para que implemente una lista enlazada doble y una lista circular y que permita insertar, eliminar y buscar elementos en ellas.
- - -
>4.3) Data Structure: Stack/Queue
- a) Crea un programa que implemente una pila (stack) y una cola (queue) utilizando un array y que permita insertar, eliminar y buscar elementos en ellas. También puedes agregar la capacidad de imprimir la pila y la cola en la consola.
- b) Extiende el programa anterior para que implemente una pila y una cola utilizando una lista enlazada y que permita insertar, eliminar y buscar elementos en ellas.
- - -
>4.4) Data Structure: Graph
- a) Crea un programa que implemente un grafo no dirigido y que permita agregar, eliminar y buscar nodos y aristas en él. También puedes agregar la capacidad de imprimir el grafo en la consola.
- b) Extiende el programa anterior para que implemente un grafo dirigido ponderado y que permita encontrar la ruta más corta entre dos nodos utilizando el algoritmo de Dijkstra.
- - -
>4.5) Data Structure: Tree
- a) Crea un programa que implemente un árbol binario de búsqueda y que permita insertar, eliminar y buscar nodos en él. También puedes agregar la capacidad de imprimir el árbol en la consola.
- b) Extiende el programa anterior para que implemente un árbol AVL y un árbol rojo-negro y que permita insertar, eliminar y buscar nodos en ellos.
- - -
>4.6) Data Structure: Trie
- a) Crea un programa que implemente un trie (árbol de prefijos) y que permita insertar, eliminar y buscar cadenas de caracteres en él. También puedes agregar la capacidad de imprimir el trie en la consola.
- b) Extiende el programa anterior para que implemente un trie comprimido (compressed trie) y que permita insertar, eliminar y buscar cadenas de caracteres en él.
- - -
>4.7) Data Structure: Heap
- a) Crea un programa que implemente un heap binario y que permita insertar, eliminar y buscar elementos en él. También puedes agregar la capacidad de imprimir el heap en la consola.
- b) Extiende el programa anterior para que implemente un heap Fibonacci y que permita insertar, eliminar y buscar elementos en él.
- - -
>4.8) Data Structure: Hashing
- a) Crea un programa que implemente una tabla de hash (hash table) utilizando una función de hash simple y que permita agregar, eliminar y buscar elementos en ella. También puedes agregar la capacidad de imprimir la tabla de hash en la consola.
- b) Extiende el programa anterior para que implemente una tabla de hash con resolución de colisiones mediante encadenamiento (chaining) y que permita agregar, eliminar y buscar elementos en ella. También puedes agregar la capacidad de imprimir la tabla de hash en la consola.
- - -
>5 ) OOP Core Concepts
+ Introduction
+ Classes
+ Data Hiding
+ Inheritance
- a) Crea una clase llamada "Círculo" que contenga el campo "radio" y los métodos "calcularÁrea" y "calcularPerímetro", y luego crea un programa que pida al usuario el radio de un círculo y muestre su área y perímetro.
- b) Crea una clase llamada "Rectángulo" que contenga los campos "ancho" y "alto" y los métodos "calcularÁrea" y "calcularPerímetro", y luego crea un programa que pida al usuario las dimensiones de un rectángulo y muestre su área y perímetro.
- c) Sistema de gestión de cuentas bancarias: El objetivo es crear un sistema de gestión de cuentas bancarias en el que se pueda realizar operaciones como depósitos, retiros, transferencias, entre otras. Puedes utilizar una clase "CuentaBancaria" como clase base y crear subclases que representen diferentes tipos de cuentas (por ejemplo, cuenta de ahorro, cuenta corriente, cuenta de inversión).
Utiliza la ocultación de datos para proteger la información sensible, como el saldo de la cuenta, y proporciona métodos públicos que permitan acceder y modificar dicha información de manera controlada.
Utiliza la herencia para crear subclases que hereden los atributos y métodos de la clase base y que agreguen funcionalidades específicas. Por ejemplo, la subclase "CuentaDeAhorro" podría tener un método que calcule el interés ganado sobre el saldo de la cuenta.
- - -
>6 ) OOP Advanced Concepts
+ Polymorphism
+ Composition, Aggregation and Association
- a) Implementar una jerarquía de clases para modelar un juego de cartas, utilizando polimorfismo para representar diferentes tipos de cartas y sus acciones. Por ejemplo, puede tener clases para Carta, CartaNormal, CartaEspecial, MazoDeCartas, etc.
- b) Crear un programa que utilice el patrón de diseño Singleton para crear una instancia única de una clase que maneja una conexión a una base de datos. La instancia única debe estar disponible para toda la aplicación y solo debe haber una instancia.
- c) Sistema de gestión de un hospital: El objetivo es crear un sistema de gestión de un hospital en el que se puedan realizar operaciones como la admisión de pacientes, el registro de su información personal y médica, la asignación de médicos y enfermeros a las diferentes salas y la programación de citas médicas.
Utiliza la composición para representar las diferentes entidades que participan en el sistema, como las salas, los pacientes, los médicos y los enfermeros. Cada entidad debe tener sus propios atributos y métodos.
Utiliza la agregación y la asociación para modelar las relaciones entre las diferentes entidades. Por ejemplo, una sala puede tener varios pacientes y un médico puede atender a varios pacientes en diferentes salas.
Utiliza el polimorfismo para crear clases abstractas que representen diferentes tipos de entidades, como "Persona" y "Empleado". Luego, crea subclases concretas que hereden de estas clases abstractas y agreguen atributos y métodos específicos.
- - -
>7 ) Standard Library
+ Standard Library Overview
+ Application of Libraries
+ Useful Functions
+ Adaptors for Functions
+ Pairs and Tuples
+ Reference Wrappers
+ Type Traits
+ Time Library
+ std::any, std::optional and std::variant
- a) Crear un programa que lea datos de un archivo CSV utilizando la biblioteca <fstream> y almacene los datos en una estructura de datos como un vector o un mapa.
- b) Crear un programa que utilice la biblioteca <chrono> para medir el tiempo que tarda en ejecutarse una sección de código.
- c) Gestión de una tienda en línea: El objetivo es crear un sistema de gestión de una tienda en línea en la que se puedan realizar operaciones como la creación y modificación de productos, la realización de pedidos y el seguimiento del estado de los mismos.
Utiliza la biblioteca <string> para el manejo de cadenas de caracteres, <vector> para el almacenamiento de productos y pedidos, y <map> para el manejo de la información de los clientes.
Utiliza la biblioteca <chrono> para medir el tiempo de entrega de los productos y el tiempo que ha pasado desde la realización del pedido hasta su entrega.
Utiliza la biblioteca <any> y <optional> para manejar datos que pueden ser desconocidos o nulos en ciertos momentos, como el estado del envío de un pedido. Utiliza <variant> para representar los diferentes tipos de productos que se pueden vender en la tienda.
Utiliza los adaptadores de funciones como std::function para definir funciones y poder utilizarlos en diferentes lugares del código sin tener que reescribirlos.
Utiliza los tipos de datos como std::pair y std::tuple para almacenar datos relacionados como el nombre y la descripción de un producto.
Utiliza los tipos de datos como std::reference_wrapper para almacenar referencias a objetos y poder manipularlos sin copiarlos.
Utiliza la biblioteca <type_traits> para definir templates y funciones que solo funcionen con ciertos tipos de datos.
- - -
>8 ) Containers
+ Containers in General
+ Sequential Containers
+ Associative Containers in General
+ Ordered Associative Containers
+ Unordered Associative Containers
+ Adaptors for Containers
- a) Crear un programa que use un contenedor std::vector para almacenar una lista de tareas y permita agregar, eliminar y mostrar tareas.
- b) Crear un programa que use un contenedor std::map para contar la cantidad de veces que aparece cada palabra en un archivo de texto.
- c) Juego de Solitario: El objetivo es crear un juego de solitario en el que se puedan mover cartas de una pila a otra hasta que todas las cartas estén en una única pila, en el orden correcto.
Utiliza contenedores secuenciales como std::vector o std::list para almacenar las cartas y las diferentes pilas de cartas.
Utiliza contenedores asociativos como std::map o std::set para almacenar la información sobre las diferentes cartas, como su valor y palo.
Utiliza los contenedores asociativos ordenados como std::set o std::map para almacenar las cartas en el orden correcto dentro de cada pila.
Utiliza los contenedores asociativos no ordenados como std::unordered_map o std::unordered_set para almacenar información adicional sobre las cartas, como su color o el número de veces que se han movido.
Utiliza los adaptadores de contenedores como std::stack o std::queue para almacenar las diferentes pilas de cartas y facilitar la manipulación de las mismas.
Utiliza iteradores para recorrer los diferentes contenedores y adaptadores y poder manipular las cartas de manera eficiente.
- - -
>9 ) Iterators and Callable Units
+ Iterators
+ Callable Units
- a) Crear un programa que use un iterador para recorrer un contenedor std::vector y mostrar todos los elementos.
- b) Crear una función de orden superior (callable unit) que tome un contenedor y una función de comparación como argumentos, y ordene el contenedor utilizando la función de comparación.
- - -
>10 ) Algorithms
+ Normal Algorithms
+ Non-Modifying Algorithms
+ Modifying Algorithms
+ More Algorithms
+ New Algorithms with C++17
- a) Crear un programa que use la función std::sort para ordenar un contenedor de enteros.
- b) Crear un programa que use la función std::find_if para buscar un elemento en un contenedor que cumpla una cierta condición.
- c) Sistema de gestión de tareas: El objetivo es crear un sistema de gestión de tareas en el que se puedan agregar, eliminar y modificar tareas, así como realizar búsquedas y filtrados de tareas por diferentes criterios.
Utiliza algoritmos no modificadores como std::find, std::find_if, std::all_of, std::none_of y std::count para buscar y contar tareas que cumplan ciertos criterios.
Utiliza algoritmos modificadores como std::transform, std::replace y std::remove para modificar y eliminar tareas en la lista de tareas.
Utiliza algoritmos de ordenamiento como std::sort y std::stable_sort para ordenar la lista de tareas según diferentes criterios, como la fecha de vencimiento o la prioridad.
Utiliza algoritmos de agrupación como std::partition y std::stable_partition para dividir la lista de tareas en dos grupos según ciertos criterios, como si han sido completadas o no.
Utiliza los nuevos algoritmos introducidos en C++17 como std::clamp y std::sample para realizar operaciones adicionales, como limitar el número de tareas que se muestran en pantalla o seleccionar una muestra aleatoria de tareas para revisar.
- - -
>11 ) Text Processing
+ Numeric
+ Strings
+ String View
+ Regular Expressions
+ Input and Output Streams
- a) Crear un programa que cuente la cantidad de palabras en un archivo de texto.
- b) Crear un programa que busque una palabra específica en un archivo de texto y la reemplace por otra.
- c) Calculadora de estadísticas: El objetivo es crear un programa que permita al usuario ingresar una serie de números y realizar diferentes operaciones estadísticas sobre ellos, como calcular la media, la mediana, la moda, el rango y la desviación estándar.
Utiliza las librerías numéricas de C++ como <cmath> y <numeric> para realizar cálculos matemáticos, como el cálculo de la desviación estándar.
Utiliza las funciones y objetos de string de C++ para procesar la entrada del usuario y extraer los números.
Utiliza la clase string_view de C++ para realizar operaciones con strings de manera eficiente.
Utiliza expresiones regulares para validar la entrada del usuario y asegurarte de que solo se ingresen números válidos.
Utiliza los streams de entrada y salida de C++ para interactuar con el usuario y mostrar los resultados de los cálculos.
- - -
>12 ) Template basics
- a) Crear una función de plantilla que devuelva el valor absoluto de cualquier tipo de número.
- b) Crear una clase de plantilla para implementar una pila (stack) que pueda contener cualquier tipo de dato.
- - -
>13 ) Template Details
- a) Crear una clase de plantilla para implementar una lista enlazada (linked list) que pueda contener cualquier tipo de dato.
- b) Crear una función de plantilla que tome un vector de cualquier tipo de dato y devuelva el valor mínimo.
- - -
>14 ) Template Techniques
- a) Crear una función de plantilla que tome dos vectores del mismo tamaño y devuelva su producto escalar.
- b) Crear una clase de plantilla que implemente una matriz (matrix) y sobrecargar el operador de multiplicación para que pueda multiplicar dos matrices de cualquier tipo de dato.
- - -
>15 ) Template Design
- a) Crear una función de plantilla que calcule el factorial de un número en tiempo de compilación.
- b) Crear una clase de plantilla que implemente un árbol binario de búsqueda (binary search tree) y sobrecargar los operadores de comparación para que pueda ordenar cualquier tipo de dato.
- - -
>16 ) Template Future
- a) Crear una función de plantilla que tome dos vectores del mismo tamaño y devuelva su suma.
- b) Crear una clase de plantilla que implemente una cola de prioridad (priority queue) que pueda contener cualquier tipo de dato.
- - -
>17 ) Memory Model
+ A quick Overview
+ Memory Model: The contract
+ Future
+ Memory Model: Synchronization and Ordering Constraints
+ Memory Model: Fences
- a) Crear un programa que muestre la ubicación en memoria de diferentes tipos de datos en diferentes sistemas operativos.
- b) Crear un programa que muestre cómo se almacenan los objetos en la memoria y cómo se pueden acceder a sus direcciones.
- c) Simulador de carrera de caballos: El objetivo es crear un programa que simule una carrera de caballos entre varios caballos. Cada caballo estará representado por un hilo separado.
Utiliza la memoria compartida de C++ para comunicar información entre los hilos, como la distancia recorrida y la posición actual de cada caballo.
Utiliza el modelo de sincronización y ordenamiento de C++ para asegurarte de que los hilos se ejecuten en el orden correcto y de que las variables compartidas se actualicen correctamente.
Utiliza los fences de C++ para garantizar que las operaciones de memoria sean ejecutadas en el orden correcto y que no haya errores de sincronización entre los hilos.
- - -
>18 ) Multithreading
+ Multithreading: Threads
+ Multithreading: Shared Data
+ Multithreading: Local Data
+ Multithreading: Tasks
- a) Crea un programa que descargue varios archivos desde Internet simultáneamente utilizando hilos (threads) y muestre el progreso de descarga de cada archivo en tiempo real.
- b) Crea un juego multijugador utilizando sockets y multithreading para manejar varias conexiones de manera simultánea.
- c) Simulador de procesamiento de imágenes en paralelo: El objetivo es crear un programa que procese una imagen y realice diferentes operaciones, como el filtrado y la conversión de formato, en paralelo utilizando múltiples hilos.
Utiliza los hilos de C++ para ejecutar las operaciones en paralelo y utiliza la memoria compartida de C++ para comunicar información entre los hilos, como los resultados parciales y los datos de entrada.
Utiliza los datos locales de C++ para asegurarte de que cada hilo tenga su propia copia de los datos de entrada y no se produzcan errores de sincronización entre los hilos.
Utiliza las tareas de C++ para crear un modelo de programación asincrónico y simplificar la gestión de hilos y la comunicación entre ellos.
- - -
>19 ) Multithreading case studies
+ Case Study: Calculate Sum of a Vector
+ Case Study: Thread-Safe Initialization of a Singleton
+ Case Study: Ongoing Optimization with CppMem
- a) Analiza el rendimiento de una aplicación que realiza cálculos intensivos utilizando diferentes enfoques de multithreading, como dividir la tarea en varios hilos o utilizar procesamiento en paralelo en GPU.
- b) Implementa un servidor web multihilo y evalúa su rendimiento utilizando herramientas de prueba de carga.
- - -
>20 ) Multithreading with template and time libraries
+ Parallel Algorithms of the Standard Template Library
+ The Time Library
- a) Crea un programa que procese una gran cantidad de datos utilizando plantillas (templates) y multithreading para mejorar el rendimiento.
- b) Implementa un reloj en tiempo real utilizando la biblioteca de tiempo (time) y hilos (threads).
- - -
>21 ) The Future: C++20 and Coding Examples
+ The Future: C++20
+ Coding Examples
+ Best Practices
- a) Utiliza las nuevas características de C++20, como los módulos y conceptos, para refactorizar un proyecto existente y mejorar su legibilidad y mantenibilidad.
- b) Implementa una aplicación que aproveche las mejoras de rendimiento y seguridad de C++20, como las operaciones atómicas de punto flotante o el manejo seguro de memoria.
- - -
>22 ) Embedded Programming and Safety-Critical Systems
+ Embedded programming Introduction
+ Safety-Critical Systems
- a) Implementa un controlador para un sistema embebido utilizando C++ y asegúrate de que cumple con los estándares de seguridad y confiabilidad requeridos.
- b) Crea un simulador para evaluar el comportamiento de un sistema embebido en diferentes condiciones y escenarios.
- - -
>23 ) High Performance
- a) Optimiza el rendimiento de una aplicación que realiza cálculos intensivos utilizando técnicas como el procesamiento en paralelo, la reducción de la sobrecarga y la optimización de la memoria.
- b) Implementa un motor de renderizado 3D utilizando C++ y optimiza su rendimiento para poder renderizar escenas complejas en tiempo real.
- - -
>24 ) Reduced Resources
- a) Implementa una aplicación que funcione en sistemas con recursos limitados, como una Raspberry Pi o un microcontrolador, y optimiza su uso de memoria y CPU.
- b) Crea un sistema de control de robots utilizando C++ y asegúrate de que funciona de manera eficiente y confiable en sistemas embebidos.
- - -
>25 ) Several Tasks Simultaneously
- a) Implementa un planificador de tareas utilizando hilos (threads) y/o procesos para permitir la ejecución simultánea de varias tareas.
- b) Crea una aplicación de gestión de archivos que permita la carga y descarga simultánea de múltiples archivos utilizando hilos (threads).
- - -
>26 ) Graph Algorithms Basics
+ Graph Introduction
+ Graph Representations
+ Graph Traversal
- a) Crea un programa que tome como entrada un grafo no dirigido y encuentre el número de componentes conectadas y el tamaño de cada componente. Puedes usar una búsqueda en profundidad (DFS) o una búsqueda en anchura (BFS) para implementar esta solución. También puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo para hacer que el programa sea más versátil.
- b) Crea un programa que resuelva el problema del árbol de expansión mínimo (Minimum Spanning Tree) de un grafo ponderado no dirigido. Puedes usar el algoritmo de Kruskal o el algoritmo de Prim para implementar esta solución. También puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo para hacer que el programa sea más versátil.
- - -
>27 ) Graph Algorithms Applications
+ Shortest Paths
+ Spanning Trees
+ Flow Problems
- a) Crea un programa que resuelva un problema de ruta más corta en un grafo dirigido ponderado. Puedes usar el algoritmo de Dijkstra para encontrar la ruta más corta entre un vértice de origen y todos los demás vértices. Además, puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo y de imprimir la ruta más corta y la distancia para cada vértice en la consola.
- b) Crea un programa que resuelva el problema de flujo máximo en un grafo dirigido ponderado. Puedes usar el algoritmo de Ford-Fulkerson o el algoritmo de Edmonds-Karp para encontrar el flujo máximo entre dos vértices. Además, puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo y de imprimir el flujo máximo y la ruta correspondiente en la consola.
- - -