# MyStudyPlanCpp

>1) C++ Fundamentals
- Crea un programa que pida al usuario un número entero y lo imprima en pantalla.
- Crea un programa que pida al usuario dos números enteros y calcule su suma, resta, multiplicación y división, imprimiendo los resultados en pantalla.

>2) Arrays and Memory Allocation
- Crea un programa que pida al usuario el tamaño de un arreglo y los valores de sus elementos, y luego calcule y muestre en pantalla la suma de todos los elementos.
- Crea un programa que genere un arreglo de números aleatorios y lo ordene de menor a mayor usando el algoritmo de selección.

>3) Recursion
- Crea una función recursiva que calcule el factorial de un número entero positivo.
- Crea una función recursiva que calcule el término n-ésimo de la secuencia de Fibonacci.

>4) Structures
- Crea una estructura llamada "Persona" que contenga los campos "nombre" y "edad", y luego crea un programa que pida al usuario los datos de dos personas y los muestre en pantalla.
- Crea una estructura llamada "Rectángulo" que contenga los campos "ancho" y "alto", y luego crea un programa que pida al usuario las dimensiones de un rectángulo y calcule su área y perímetro.

>5) OOP Core Concepts
- Crea una clase llamada "Círculo" que contenga el campo "radio" y los métodos "calcularÁrea" y "calcularPerímetro", y luego crea un programa que pida al usuario el radio de un círculo y muestre su área y perímetro.
- Crea una clase llamada "Rectángulo" que contenga los campos "ancho" y "alto" y los métodos "calcularÁrea" y "calcularPerímetro", y luego crea un programa que pida al usuario las dimensiones de un rectángulo y muestre su área y perímetro.

>6) OOP Advanced Concepts
- Implementar una jerarquía de clases para modelar un juego de cartas, utilizando polimorfismo para representar diferentes tipos de cartas y sus acciones. Por ejemplo, puede tener clases para Carta, CartaNormal, CartaEspecial, MazoDeCartas, etc.
- Crear un programa que utilice el patrón de diseño Singleton para crear una instancia única de una clase que maneja una conexión a una base de datos. La instancia única debe estar disponible para toda la aplicación y solo debe haber una instancia.

>7) Standard Library
- Crear un programa que lea datos de un archivo CSV utilizando la biblioteca <fstream> y almacene los datos en una estructura de datos como un vector o un mapa.
- Crear un programa que utilice la biblioteca <chrono> para medir el tiempo que tarda en ejecutarse una sección de código.

>8) Containers
- Crear un programa que use un contenedor std::vector para almacenar una lista de tareas y permita agregar, eliminar y mostrar tareas.
- Crear un programa que use un contenedor std::map para contar la cantidad de veces que aparece cada palabra en un archivo de texto.

>9) Iterators and Callable Units
- Crear un programa que use un iterador para recorrer un contenedor std::vector y mostrar todos los elementos.
- Crear una función de orden superior (callable unit) que tome un contenedor y una función de comparación como argumentos, y ordene el contenedor utilizando la función de comparación.

>10) Algorithms
- Crear un programa que use la función std::sort para ordenar un contenedor de enteros.
- Crear un programa que use la función std::find_if para buscar un elemento en un contenedor que cumpla una cierta condición.

>11) Text Processing
- Crear un programa que cuente la cantidad de palabras en un archivo de texto.
- Crear un programa que busque una palabra específica en un archivo de texto y la reemplace por otra.

>12) Template basics
- Crear una función de plantilla que devuelva el valor absoluto de cualquier tipo de número.
- Crear una clase de plantilla para implementar una pila (stack) que pueda contener cualquier tipo de dato.

>13) Template Details
- Crear una clase de plantilla para implementar una lista enlazada (linked list) que pueda contener cualquier tipo de dato.
- Crear una función de plantilla que tome un vector de cualquier tipo de dato y devuelva el valor mínimo.

>14) Template Techniques
- Crear una función de plantilla que tome dos vectores del mismo tamaño y devuelva su producto escalar.
- Crear una clase de plantilla que implemente una matriz (matrix) y sobrecargar el operador de multiplicación para que pueda multiplicar dos matrices de cualquier tipo de dato.

>15) Template Design
- Crear una función de plantilla que calcule el factorial de un número en tiempo de compilación.
- Crear una clase de plantilla que implemente un árbol binario de búsqueda (binary search tree) y sobrecargar los operadores de comparación para que pueda ordenar cualquier tipo de dato.

>16) Template Future
- Crear una función de plantilla que tome dos vectores del mismo tamaño y devuelva su suma.
- Crear una clase de plantilla que implemente una cola de prioridad (priority queue) que pueda contener cualquier tipo de dato.

>17) Memory Model
- Crear un programa que muestre la ubicación en memoria de diferentes tipos de datos en diferentes sistemas operativos.
- Crear un programa que muestre cómo se almacenan los objetos en la memoria y cómo se pueden acceder a sus direcciones.

>18) Multithreading
- Crea un programa que descargue varios archivos desde Internet simultáneamente utilizando hilos (threads) y muestre el progreso de descarga de cada archivo en tiempo real.
- Crea un juego multijugador utilizando sockets y multithreading para manejar varias conexiones de manera simultánea.

>19) Multithreading case studies
- Analiza el rendimiento de una aplicación que realiza cálculos intensivos utilizando diferentes enfoques de multithreading, como dividir la tarea en varios hilos o utilizar procesamiento en paralelo en GPU.
- Implementa un servidor web multihilo y evalúa su rendimiento utilizando herramientas de prueba de carga.

>20) Multithreading with template and time libraries
- Crea un programa que procese una gran cantidad de datos utilizando plantillas (templates) y multithreading para mejorar el rendimiento.
- Implementa un reloj en tiempo real utilizando la biblioteca de tiempo (time) y hilos (threads).

>21) The Future: C++20 and Coding Examples
- Utiliza las nuevas características de C++20, como los módulos y conceptos, para refactorizar un proyecto existente y mejorar su legibilidad y mantenibilidad.
- Implementa una aplicación que aproveche las mejoras de rendimiento y seguridad de C++20, como las operaciones atómicas de punto flotante o el manejo seguro de memoria.

>22) Embedded Programming and Safety-Critical Systems
- Implementa un controlador para un sistema embebido utilizando C++ y asegúrate de que cumple con los estándares de seguridad y confiabilidad requeridos.
- Crea un simulador para evaluar el comportamiento de un sistema embebido en diferentes condiciones y escenarios.

>23) High Performance
- Optimiza el rendimiento de una aplicación que realiza cálculos intensivos utilizando técnicas como el procesamiento en paralelo, la reducción de la sobrecarga y la optimización de la memoria.
- Implementa un motor de renderizado 3D utilizando C++ y optimiza su rendimiento para poder renderizar escenas complejas en tiempo real.

>24) Reduced Resources
- Implementa una aplicación que funcione en sistemas con recursos limitados, como una Raspberry Pi o un microcontrolador, y optimiza su uso de memoria y CPU.
- Crea un sistema de control de robots utilizando C++ y asegúrate de que funciona de manera eficiente y confiable en sistemas embebidos.

>25) Several Tasks Simultaneously
- Implementa un planificador de tareas utilizando hilos (threads) y/o procesos para permitir la ejecución simultánea de varias tareas.
- Crea una aplicación de gestión de archivos que permita la carga y descarga simultánea de múltiples archivos utilizando hilos (threads).

>26) Graph Algorithms Basics
- Crea un programa que tome como entrada un grafo no dirigido y encuentre el número de componentes conectadas y el tamaño de cada componente. Puedes usar una búsqueda en profundidad (DFS) o una búsqueda en anchura (BFS) para implementar esta solución. También puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo para hacer que el programa sea más versátil.
- Crea un programa que resuelva el problema del árbol de expansión mínimo (Minimum Spanning Tree) de un grafo ponderado no dirigido. Puedes usar el algoritmo de Kruskal o el algoritmo de Prim para implementar esta solución. También puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo para hacer que el programa sea más versátil.

>27) Graph Algorithms Applications
- Crea un programa que resuelva un problema de ruta más corta en un grafo dirigido ponderado. Puedes usar el algoritmo de Dijkstra para encontrar la ruta más corta entre un vértice de origen y todos los demás vértices. Además, puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo y de imprimir la ruta más corta y la distancia para cada vértice en la consola.
- Crea un programa que resuelva el problema de flujo máximo en un grafo dirigido ponderado. Puedes usar el algoritmo de Ford-Fulkerson o el algoritmo de Edmonds-Karp para encontrar el flujo máximo entre dos vértices. Además, puedes agregar la capacidad de leer y escribir gráficos desde y hacia un archivo y de imprimir el flujo máximo y la ruta correspondiente en la consola.